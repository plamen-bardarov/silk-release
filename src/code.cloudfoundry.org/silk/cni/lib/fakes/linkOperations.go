// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"net"
	"sync"

	"github.com/containernetworking/cni/pkg/types"
	"github.com/vishvananda/netlink"
)

type LinkOperations struct {
	DeleteLinkByNameStub        func(string) error
	deleteLinkByNameMutex       sync.RWMutex
	deleteLinkByNameArgsForCall []struct {
		arg1 string
	}
	deleteLinkByNameReturns struct {
		result1 error
	}
	deleteLinkByNameReturnsOnCall map[int]struct {
		result1 error
	}
	DisableIPv6Stub        func(string) error
	disableIPv6Mutex       sync.RWMutex
	disableIPv6ArgsForCall []struct {
		arg1 string
	}
	disableIPv6Returns struct {
		result1 error
	}
	disableIPv6ReturnsOnCall map[int]struct {
		result1 error
	}
	EnableIPv4ForwardingStub        func() error
	enableIPv4ForwardingMutex       sync.RWMutex
	enableIPv4ForwardingArgsForCall []struct {
	}
	enableIPv4ForwardingReturns struct {
		result1 error
	}
	enableIPv4ForwardingReturnsOnCall map[int]struct {
		result1 error
	}
	EnableIPv6Stub        func(string) error
	enableIPv6Mutex       sync.RWMutex
	enableIPv6ArgsForCall []struct {
		arg1 string
	}
	enableIPv6Returns struct {
		result1 error
	}
	enableIPv6ReturnsOnCall map[int]struct {
		result1 error
	}
	EnableIPv6ForwardingStub        func() error
	enableIPv6ForwardingMutex       sync.RWMutex
	enableIPv6ForwardingArgsForCall []struct {
	}
	enableIPv6ForwardingReturns struct {
		result1 error
	}
	enableIPv6ForwardingReturnsOnCall map[int]struct {
		result1 error
	}
	EnableReversePathFilteringStub        func(string) error
	enableReversePathFilteringMutex       sync.RWMutex
	enableReversePathFilteringArgsForCall []struct {
		arg1 string
	}
	enableReversePathFilteringReturns struct {
		result1 error
	}
	enableReversePathFilteringReturnsOnCall map[int]struct {
		result1 error
	}
	RenameLinkStub        func(string, string) error
	renameLinkMutex       sync.RWMutex
	renameLinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameLinkReturns struct {
		result1 error
	}
	renameLinkReturnsOnCall map[int]struct {
		result1 error
	}
	Route6AddAllStub        func([]*types.Route, string) error
	route6AddAllMutex       sync.RWMutex
	route6AddAllArgsForCall []struct {
		arg1 []*types.Route
		arg2 string
	}
	route6AddAllReturns struct {
		result1 error
	}
	route6AddAllReturnsOnCall map[int]struct {
		result1 error
	}
	RouteAddAllStub        func([]*types.Route, net.IP) error
	routeAddAllMutex       sync.RWMutex
	routeAddAllArgsForCall []struct {
		arg1 []*types.Route
		arg2 net.IP
	}
	routeAddAllReturns struct {
		result1 error
	}
	routeAddAllReturnsOnCall map[int]struct {
		result1 error
	}
	SetPointToPointAddressStub        func(netlink.Link, net.IP, net.IP) error
	setPointToPointAddressMutex       sync.RWMutex
	setPointToPointAddressArgsForCall []struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.IP
	}
	setPointToPointAddressReturns struct {
		result1 error
	}
	setPointToPointAddressReturnsOnCall map[int]struct {
		result1 error
	}
	StaticNeighborIPv6Stub        func(netlink.Link, net.IP, net.HardwareAddr) error
	staticNeighborIPv6Mutex       sync.RWMutex
	staticNeighborIPv6ArgsForCall []struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}
	staticNeighborIPv6Returns struct {
		result1 error
	}
	staticNeighborIPv6ReturnsOnCall map[int]struct {
		result1 error
	}
	StaticNeighborNoARPStub        func(netlink.Link, net.IP, net.HardwareAddr) error
	staticNeighborNoARPMutex       sync.RWMutex
	staticNeighborNoARPArgsForCall []struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}
	staticNeighborNoARPReturns struct {
		result1 error
	}
	staticNeighborNoARPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *LinkOperations) DeleteLinkByName(arg1 string) error {
	fake.deleteLinkByNameMutex.Lock()
	ret, specificReturn := fake.deleteLinkByNameReturnsOnCall[len(fake.deleteLinkByNameArgsForCall)]
	fake.deleteLinkByNameArgsForCall = append(fake.deleteLinkByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteLinkByNameStub
	fakeReturns := fake.deleteLinkByNameReturns
	fake.recordInvocation("DeleteLinkByName", []interface{}{arg1})
	fake.deleteLinkByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) DeleteLinkByNameCallCount() int {
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	return len(fake.deleteLinkByNameArgsForCall)
}

func (fake *LinkOperations) DeleteLinkByNameCalls(stub func(string) error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = stub
}

func (fake *LinkOperations) DeleteLinkByNameArgsForCall(i int) string {
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	argsForCall := fake.deleteLinkByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) DeleteLinkByNameReturns(result1 error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = nil
	fake.deleteLinkByNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DeleteLinkByNameReturnsOnCall(i int, result1 error) {
	fake.deleteLinkByNameMutex.Lock()
	defer fake.deleteLinkByNameMutex.Unlock()
	fake.DeleteLinkByNameStub = nil
	if fake.deleteLinkByNameReturnsOnCall == nil {
		fake.deleteLinkByNameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteLinkByNameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DisableIPv6(arg1 string) error {
	fake.disableIPv6Mutex.Lock()
	ret, specificReturn := fake.disableIPv6ReturnsOnCall[len(fake.disableIPv6ArgsForCall)]
	fake.disableIPv6ArgsForCall = append(fake.disableIPv6ArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DisableIPv6Stub
	fakeReturns := fake.disableIPv6Returns
	fake.recordInvocation("DisableIPv6", []interface{}{arg1})
	fake.disableIPv6Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) DisableIPv6CallCount() int {
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	return len(fake.disableIPv6ArgsForCall)
}

func (fake *LinkOperations) DisableIPv6Calls(stub func(string) error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = stub
}

func (fake *LinkOperations) DisableIPv6ArgsForCall(i int) string {
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	argsForCall := fake.disableIPv6ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) DisableIPv6Returns(result1 error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = nil
	fake.disableIPv6Returns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) DisableIPv6ReturnsOnCall(i int, result1 error) {
	fake.disableIPv6Mutex.Lock()
	defer fake.disableIPv6Mutex.Unlock()
	fake.DisableIPv6Stub = nil
	if fake.disableIPv6ReturnsOnCall == nil {
		fake.disableIPv6ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableIPv6ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv4Forwarding() error {
	fake.enableIPv4ForwardingMutex.Lock()
	ret, specificReturn := fake.enableIPv4ForwardingReturnsOnCall[len(fake.enableIPv4ForwardingArgsForCall)]
	fake.enableIPv4ForwardingArgsForCall = append(fake.enableIPv4ForwardingArgsForCall, struct {
	}{})
	stub := fake.EnableIPv4ForwardingStub
	fakeReturns := fake.enableIPv4ForwardingReturns
	fake.recordInvocation("EnableIPv4Forwarding", []interface{}{})
	fake.enableIPv4ForwardingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableIPv4ForwardingCallCount() int {
	fake.enableIPv4ForwardingMutex.RLock()
	defer fake.enableIPv4ForwardingMutex.RUnlock()
	return len(fake.enableIPv4ForwardingArgsForCall)
}

func (fake *LinkOperations) EnableIPv4ForwardingCalls(stub func() error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = stub
}

func (fake *LinkOperations) EnableIPv4ForwardingReturns(result1 error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = nil
	fake.enableIPv4ForwardingReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv4ForwardingReturnsOnCall(i int, result1 error) {
	fake.enableIPv4ForwardingMutex.Lock()
	defer fake.enableIPv4ForwardingMutex.Unlock()
	fake.EnableIPv4ForwardingStub = nil
	if fake.enableIPv4ForwardingReturnsOnCall == nil {
		fake.enableIPv4ForwardingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableIPv4ForwardingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv6(arg1 string) error {
	fake.enableIPv6Mutex.Lock()
	ret, specificReturn := fake.enableIPv6ReturnsOnCall[len(fake.enableIPv6ArgsForCall)]
	fake.enableIPv6ArgsForCall = append(fake.enableIPv6ArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EnableIPv6Stub
	fakeReturns := fake.enableIPv6Returns
	fake.recordInvocation("EnableIPv6", []interface{}{arg1})
	fake.enableIPv6Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableIPv6CallCount() int {
	fake.enableIPv6Mutex.RLock()
	defer fake.enableIPv6Mutex.RUnlock()
	return len(fake.enableIPv6ArgsForCall)
}

func (fake *LinkOperations) EnableIPv6Calls(stub func(string) error) {
	fake.enableIPv6Mutex.Lock()
	defer fake.enableIPv6Mutex.Unlock()
	fake.EnableIPv6Stub = stub
}

func (fake *LinkOperations) EnableIPv6ArgsForCall(i int) string {
	fake.enableIPv6Mutex.RLock()
	defer fake.enableIPv6Mutex.RUnlock()
	argsForCall := fake.enableIPv6ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) EnableIPv6Returns(result1 error) {
	fake.enableIPv6Mutex.Lock()
	defer fake.enableIPv6Mutex.Unlock()
	fake.EnableIPv6Stub = nil
	fake.enableIPv6Returns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv6ReturnsOnCall(i int, result1 error) {
	fake.enableIPv6Mutex.Lock()
	defer fake.enableIPv6Mutex.Unlock()
	fake.EnableIPv6Stub = nil
	if fake.enableIPv6ReturnsOnCall == nil {
		fake.enableIPv6ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableIPv6ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv6Forwarding() error {
	fake.enableIPv6ForwardingMutex.Lock()
	ret, specificReturn := fake.enableIPv6ForwardingReturnsOnCall[len(fake.enableIPv6ForwardingArgsForCall)]
	fake.enableIPv6ForwardingArgsForCall = append(fake.enableIPv6ForwardingArgsForCall, struct {
	}{})
	stub := fake.EnableIPv6ForwardingStub
	fakeReturns := fake.enableIPv6ForwardingReturns
	fake.recordInvocation("EnableIPv6Forwarding", []interface{}{})
	fake.enableIPv6ForwardingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableIPv6ForwardingCallCount() int {
	fake.enableIPv6ForwardingMutex.RLock()
	defer fake.enableIPv6ForwardingMutex.RUnlock()
	return len(fake.enableIPv6ForwardingArgsForCall)
}

func (fake *LinkOperations) EnableIPv6ForwardingCalls(stub func() error) {
	fake.enableIPv6ForwardingMutex.Lock()
	defer fake.enableIPv6ForwardingMutex.Unlock()
	fake.EnableIPv6ForwardingStub = stub
}

func (fake *LinkOperations) EnableIPv6ForwardingReturns(result1 error) {
	fake.enableIPv6ForwardingMutex.Lock()
	defer fake.enableIPv6ForwardingMutex.Unlock()
	fake.EnableIPv6ForwardingStub = nil
	fake.enableIPv6ForwardingReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableIPv6ForwardingReturnsOnCall(i int, result1 error) {
	fake.enableIPv6ForwardingMutex.Lock()
	defer fake.enableIPv6ForwardingMutex.Unlock()
	fake.EnableIPv6ForwardingStub = nil
	if fake.enableIPv6ForwardingReturnsOnCall == nil {
		fake.enableIPv6ForwardingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableIPv6ForwardingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableReversePathFiltering(arg1 string) error {
	fake.enableReversePathFilteringMutex.Lock()
	ret, specificReturn := fake.enableReversePathFilteringReturnsOnCall[len(fake.enableReversePathFilteringArgsForCall)]
	fake.enableReversePathFilteringArgsForCall = append(fake.enableReversePathFilteringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EnableReversePathFilteringStub
	fakeReturns := fake.enableReversePathFilteringReturns
	fake.recordInvocation("EnableReversePathFiltering", []interface{}{arg1})
	fake.enableReversePathFilteringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) EnableReversePathFilteringCallCount() int {
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	return len(fake.enableReversePathFilteringArgsForCall)
}

func (fake *LinkOperations) EnableReversePathFilteringCalls(stub func(string) error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = stub
}

func (fake *LinkOperations) EnableReversePathFilteringArgsForCall(i int) string {
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	argsForCall := fake.enableReversePathFilteringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *LinkOperations) EnableReversePathFilteringReturns(result1 error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = nil
	fake.enableReversePathFilteringReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) EnableReversePathFilteringReturnsOnCall(i int, result1 error) {
	fake.enableReversePathFilteringMutex.Lock()
	defer fake.enableReversePathFilteringMutex.Unlock()
	fake.EnableReversePathFilteringStub = nil
	if fake.enableReversePathFilteringReturnsOnCall == nil {
		fake.enableReversePathFilteringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableReversePathFilteringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RenameLink(arg1 string, arg2 string) error {
	fake.renameLinkMutex.Lock()
	ret, specificReturn := fake.renameLinkReturnsOnCall[len(fake.renameLinkArgsForCall)]
	fake.renameLinkArgsForCall = append(fake.renameLinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameLinkStub
	fakeReturns := fake.renameLinkReturns
	fake.recordInvocation("RenameLink", []interface{}{arg1, arg2})
	fake.renameLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) RenameLinkCallCount() int {
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	return len(fake.renameLinkArgsForCall)
}

func (fake *LinkOperations) RenameLinkCalls(stub func(string, string) error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = stub
}

func (fake *LinkOperations) RenameLinkArgsForCall(i int) (string, string) {
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	argsForCall := fake.renameLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LinkOperations) RenameLinkReturns(result1 error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = nil
	fake.renameLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RenameLinkReturnsOnCall(i int, result1 error) {
	fake.renameLinkMutex.Lock()
	defer fake.renameLinkMutex.Unlock()
	fake.RenameLinkStub = nil
	if fake.renameLinkReturnsOnCall == nil {
		fake.renameLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) Route6AddAll(arg1 []*types.Route, arg2 string) error {
	var arg1Copy []*types.Route
	if arg1 != nil {
		arg1Copy = make([]*types.Route, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.route6AddAllMutex.Lock()
	ret, specificReturn := fake.route6AddAllReturnsOnCall[len(fake.route6AddAllArgsForCall)]
	fake.route6AddAllArgsForCall = append(fake.route6AddAllArgsForCall, struct {
		arg1 []*types.Route
		arg2 string
	}{arg1Copy, arg2})
	stub := fake.Route6AddAllStub
	fakeReturns := fake.route6AddAllReturns
	fake.recordInvocation("Route6AddAll", []interface{}{arg1Copy, arg2})
	fake.route6AddAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) Route6AddAllCallCount() int {
	fake.route6AddAllMutex.RLock()
	defer fake.route6AddAllMutex.RUnlock()
	return len(fake.route6AddAllArgsForCall)
}

func (fake *LinkOperations) Route6AddAllCalls(stub func([]*types.Route, string) error) {
	fake.route6AddAllMutex.Lock()
	defer fake.route6AddAllMutex.Unlock()
	fake.Route6AddAllStub = stub
}

func (fake *LinkOperations) Route6AddAllArgsForCall(i int) ([]*types.Route, string) {
	fake.route6AddAllMutex.RLock()
	defer fake.route6AddAllMutex.RUnlock()
	argsForCall := fake.route6AddAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LinkOperations) Route6AddAllReturns(result1 error) {
	fake.route6AddAllMutex.Lock()
	defer fake.route6AddAllMutex.Unlock()
	fake.Route6AddAllStub = nil
	fake.route6AddAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) Route6AddAllReturnsOnCall(i int, result1 error) {
	fake.route6AddAllMutex.Lock()
	defer fake.route6AddAllMutex.Unlock()
	fake.Route6AddAllStub = nil
	if fake.route6AddAllReturnsOnCall == nil {
		fake.route6AddAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.route6AddAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RouteAddAll(arg1 []*types.Route, arg2 net.IP) error {
	var arg1Copy []*types.Route
	if arg1 != nil {
		arg1Copy = make([]*types.Route, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.routeAddAllMutex.Lock()
	ret, specificReturn := fake.routeAddAllReturnsOnCall[len(fake.routeAddAllArgsForCall)]
	fake.routeAddAllArgsForCall = append(fake.routeAddAllArgsForCall, struct {
		arg1 []*types.Route
		arg2 net.IP
	}{arg1Copy, arg2})
	stub := fake.RouteAddAllStub
	fakeReturns := fake.routeAddAllReturns
	fake.recordInvocation("RouteAddAll", []interface{}{arg1Copy, arg2})
	fake.routeAddAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) RouteAddAllCallCount() int {
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	return len(fake.routeAddAllArgsForCall)
}

func (fake *LinkOperations) RouteAddAllCalls(stub func([]*types.Route, net.IP) error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = stub
}

func (fake *LinkOperations) RouteAddAllArgsForCall(i int) ([]*types.Route, net.IP) {
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	argsForCall := fake.routeAddAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LinkOperations) RouteAddAllReturns(result1 error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = nil
	fake.routeAddAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) RouteAddAllReturnsOnCall(i int, result1 error) {
	fake.routeAddAllMutex.Lock()
	defer fake.routeAddAllMutex.Unlock()
	fake.RouteAddAllStub = nil
	if fake.routeAddAllReturnsOnCall == nil {
		fake.routeAddAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.routeAddAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) SetPointToPointAddress(arg1 netlink.Link, arg2 net.IP, arg3 net.IP) error {
	fake.setPointToPointAddressMutex.Lock()
	ret, specificReturn := fake.setPointToPointAddressReturnsOnCall[len(fake.setPointToPointAddressArgsForCall)]
	fake.setPointToPointAddressArgsForCall = append(fake.setPointToPointAddressArgsForCall, struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.IP
	}{arg1, arg2, arg3})
	stub := fake.SetPointToPointAddressStub
	fakeReturns := fake.setPointToPointAddressReturns
	fake.recordInvocation("SetPointToPointAddress", []interface{}{arg1, arg2, arg3})
	fake.setPointToPointAddressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) SetPointToPointAddressCallCount() int {
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	return len(fake.setPointToPointAddressArgsForCall)
}

func (fake *LinkOperations) SetPointToPointAddressCalls(stub func(netlink.Link, net.IP, net.IP) error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = stub
}

func (fake *LinkOperations) SetPointToPointAddressArgsForCall(i int) (netlink.Link, net.IP, net.IP) {
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	argsForCall := fake.setPointToPointAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LinkOperations) SetPointToPointAddressReturns(result1 error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = nil
	fake.setPointToPointAddressReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) SetPointToPointAddressReturnsOnCall(i int, result1 error) {
	fake.setPointToPointAddressMutex.Lock()
	defer fake.setPointToPointAddressMutex.Unlock()
	fake.SetPointToPointAddressStub = nil
	if fake.setPointToPointAddressReturnsOnCall == nil {
		fake.setPointToPointAddressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPointToPointAddressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborIPv6(arg1 netlink.Link, arg2 net.IP, arg3 net.HardwareAddr) error {
	fake.staticNeighborIPv6Mutex.Lock()
	ret, specificReturn := fake.staticNeighborIPv6ReturnsOnCall[len(fake.staticNeighborIPv6ArgsForCall)]
	fake.staticNeighborIPv6ArgsForCall = append(fake.staticNeighborIPv6ArgsForCall, struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}{arg1, arg2, arg3})
	stub := fake.StaticNeighborIPv6Stub
	fakeReturns := fake.staticNeighborIPv6Returns
	fake.recordInvocation("StaticNeighborIPv6", []interface{}{arg1, arg2, arg3})
	fake.staticNeighborIPv6Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) StaticNeighborIPv6CallCount() int {
	fake.staticNeighborIPv6Mutex.RLock()
	defer fake.staticNeighborIPv6Mutex.RUnlock()
	return len(fake.staticNeighborIPv6ArgsForCall)
}

func (fake *LinkOperations) StaticNeighborIPv6Calls(stub func(netlink.Link, net.IP, net.HardwareAddr) error) {
	fake.staticNeighborIPv6Mutex.Lock()
	defer fake.staticNeighborIPv6Mutex.Unlock()
	fake.StaticNeighborIPv6Stub = stub
}

func (fake *LinkOperations) StaticNeighborIPv6ArgsForCall(i int) (netlink.Link, net.IP, net.HardwareAddr) {
	fake.staticNeighborIPv6Mutex.RLock()
	defer fake.staticNeighborIPv6Mutex.RUnlock()
	argsForCall := fake.staticNeighborIPv6ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LinkOperations) StaticNeighborIPv6Returns(result1 error) {
	fake.staticNeighborIPv6Mutex.Lock()
	defer fake.staticNeighborIPv6Mutex.Unlock()
	fake.StaticNeighborIPv6Stub = nil
	fake.staticNeighborIPv6Returns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborIPv6ReturnsOnCall(i int, result1 error) {
	fake.staticNeighborIPv6Mutex.Lock()
	defer fake.staticNeighborIPv6Mutex.Unlock()
	fake.StaticNeighborIPv6Stub = nil
	if fake.staticNeighborIPv6ReturnsOnCall == nil {
		fake.staticNeighborIPv6ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.staticNeighborIPv6ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborNoARP(arg1 netlink.Link, arg2 net.IP, arg3 net.HardwareAddr) error {
	fake.staticNeighborNoARPMutex.Lock()
	ret, specificReturn := fake.staticNeighborNoARPReturnsOnCall[len(fake.staticNeighborNoARPArgsForCall)]
	fake.staticNeighborNoARPArgsForCall = append(fake.staticNeighborNoARPArgsForCall, struct {
		arg1 netlink.Link
		arg2 net.IP
		arg3 net.HardwareAddr
	}{arg1, arg2, arg3})
	stub := fake.StaticNeighborNoARPStub
	fakeReturns := fake.staticNeighborNoARPReturns
	fake.recordInvocation("StaticNeighborNoARP", []interface{}{arg1, arg2, arg3})
	fake.staticNeighborNoARPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LinkOperations) StaticNeighborNoARPCallCount() int {
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	return len(fake.staticNeighborNoARPArgsForCall)
}

func (fake *LinkOperations) StaticNeighborNoARPCalls(stub func(netlink.Link, net.IP, net.HardwareAddr) error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = stub
}

func (fake *LinkOperations) StaticNeighborNoARPArgsForCall(i int) (netlink.Link, net.IP, net.HardwareAddr) {
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	argsForCall := fake.staticNeighborNoARPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LinkOperations) StaticNeighborNoARPReturns(result1 error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = nil
	fake.staticNeighborNoARPReturns = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) StaticNeighborNoARPReturnsOnCall(i int, result1 error) {
	fake.staticNeighborNoARPMutex.Lock()
	defer fake.staticNeighborNoARPMutex.Unlock()
	fake.StaticNeighborNoARPStub = nil
	if fake.staticNeighborNoARPReturnsOnCall == nil {
		fake.staticNeighborNoARPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.staticNeighborNoARPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LinkOperations) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteLinkByNameMutex.RLock()
	defer fake.deleteLinkByNameMutex.RUnlock()
	fake.disableIPv6Mutex.RLock()
	defer fake.disableIPv6Mutex.RUnlock()
	fake.enableIPv4ForwardingMutex.RLock()
	defer fake.enableIPv4ForwardingMutex.RUnlock()
	fake.enableIPv6Mutex.RLock()
	defer fake.enableIPv6Mutex.RUnlock()
	fake.enableIPv6ForwardingMutex.RLock()
	defer fake.enableIPv6ForwardingMutex.RUnlock()
	fake.enableReversePathFilteringMutex.RLock()
	defer fake.enableReversePathFilteringMutex.RUnlock()
	fake.renameLinkMutex.RLock()
	defer fake.renameLinkMutex.RUnlock()
	fake.route6AddAllMutex.RLock()
	defer fake.route6AddAllMutex.RUnlock()
	fake.routeAddAllMutex.RLock()
	defer fake.routeAddAllMutex.RUnlock()
	fake.setPointToPointAddressMutex.RLock()
	defer fake.setPointToPointAddressMutex.RUnlock()
	fake.staticNeighborIPv6Mutex.RLock()
	defer fake.staticNeighborIPv6Mutex.RUnlock()
	fake.staticNeighborNoARPMutex.RLock()
	defer fake.staticNeighborNoARPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *LinkOperations) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
